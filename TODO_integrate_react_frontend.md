# TODO: Integrate Existing React Frontend into Self-Contained Neutralinojs Desktop App

This document outlines the tasks required to modify the self-contained Neutralinojs desktop application to use the existing React frontend (from the main `frontend/` directory) instead of the simple HTML/JS UI.

## Phase 1: Adapt React Frontend for Neutralinojs Environment & Embedded Backend

### Task 1.1: Modify React's WebSocket Communication Logic
*   **Objective:** Update the React application to connect to the embedded Python backend, which runs on a dynamic port.
*   **Steps:**
    1.  Identify the WebSocket connection logic in the React codebase (likely in a service, utility, or context, e.g., `frontend/providers/chat-provider.tsx`).
    2.  Remove any hardcoded external WebSocket URL (e.g., `ws://localhost:8000/ws`).
    3.  **Mechanism for Dynamic Port & Workspace Path:** The Neutralinojs shell (`ii_agent_desktop/app/js/main.js` or a minimal bootstrap script loaded by React's `index.html`) will launch the Python backend, capture its dynamic port, and get the Neutralino data path. These need to be passed to the React app.
        *   **Proposed Method:** The Neutralinojs shell script will inject these values as global JavaScript variables (e.g., `window.NL_EMBEDDED_PYTHON_PORT` and `window.NL_APP_DATA_PATH`) *before* the main React application bundle (e.g., `main.js` or similar from React's build) is loaded and executed by the `index.html` of the React build. This means the `index.html` used by Neutralinojs (which will be the one from React's build output) must load this shell script first, or the shell script itself loads React.
    4.  Modify the React WebSocket logic to read `window.NL_EMBEDDED_PYTHON_PORT` (and potentially `window.NL_DEVICE_ID` if also injected) and construct the local WebSocket URL (e.g., `ws://localhost:${window.NL_EMBEDDED_PYTHON_PORT}?device_id=...`).
    5.  Ensure the React app sends and receives `RealtimeEvent`-like JSON messages compatible with `embedded_backend_main.py` (this should align with existing `frontend/typings/agent.ts`).
    6.  The `deviceId` for the WebSocket connection should be generated and managed by the React app (e.g., using `localStorage` or a utility function) or it could be generated by the Neutralinojs shell and injected as `window.NL_DEVICE_ID`.

### Task 1.2: Integrate Neutralinojs API Access into React
*   **Objective:** Allow React components to use Neutralinojs native APIs for desktop interactions.
*   **Steps:**
    1.  Ensure `neutralino.js` (the Neutralinojs client library) is correctly loaded by the React application's main `index.html`. This will be the `index.html` file generated by the React build process, which will then be used as the main entry point for the Neutralinojs application.
    2.  Create React custom hooks (e.g., `useNeutralinoOS`, `useNeutralinoFilesystem`, `useNeutralinoApp`) or services/utility functions to wrap common Neutralinojs API calls. This provides a clean, React-idiomatic way to use these APIs within components.
        *   Examples: `Neutralino.os.showOpenDialog`, `Neutralino.filesystem.getPath('data')`, `Neutralino.app.exit()`.
    3.  The React app should use `window.NL_APP_DATA_PATH` (from Task 1.1.3, obtained via `Neutralino.filesystem.getPath('data')` in the shell) as the base for constructing any display paths or for reasoning about where application data is stored. Actual file operations for the agent's workspace are handled by the backend, but the frontend might need this path for context.

### Task 1.3: Adapt File Upload Functionality in React
*   **Objective:** Modify the existing file upload feature in the React frontend to work with the embedded backend (using WebSocket for transfer) and Neutralinojs file dialogs.
*   **Steps:**
    1.  Replace existing browser-based file input elements (`<input type="file">`) and their associated logic with calls to `Neutralino.os.showOpenDialog` (likely wrapped via a custom hook or service from Task 1.2).
    2.  After file selection, read the file content using Neutralinojs filesystem APIs (`Neutralino.filesystem.readFile` for text or `Neutralino.filesystem.readBinaryFile` then convert to a base64 data URL for binary files).
    3.  Send the file data (filename, base64 data URL content) via the WebSocket connection to the embedded Python backend, using the `FILE_UPLOAD_REQUEST` event type (as defined in `embedded_backend_main.py`).
    4.  Handle `FILE_UPLOAD_SUCCESS` and `FILE_UPLOAD_FAILURE` events from the backend to update the React UI.

### Task 1.4: (If applicable) Adapt NeutralinoBridgeTool Interaction
*   **Objective:** Ensure the React frontend can handle `NEUTRALINO_COMMAND` events from the backend and send `NEUTRALINO_RESULT` events back if the `NeutralinoBridgeTool` is used by the agent.
*   **Steps:**
    1.  The React WebSocket message handler needs to listen for `NEUTRALINO_COMMAND` events from the backend.
    2.  Upon receiving such an event, it should parse the `action` and `details` from the command's payload.
    3.  It will then trigger the appropriate Neutralinojs API call (e.g., `Neutralino.os.showNotification(details.title, details.content)`) using the wrapped functions (from Task 1.2).
    4.  After the Neutralinojs API call completes (or errors), the React app must send a `NEUTRALINO_RESULT` event back to the backend via WebSocket, including the original `command_id`, a `status` ("success" or "error"), and a `payload` containing the result or error information.

### Task 1.5: Review React Routing
*   **Objective:** Ensure React Router (or other routing solutions if used by the `frontend/` app) works correctly within the Neutralinojs environment.
*   **Steps:**
    1.  Test navigation between different views/pages within the React application once it's running inside Neutralinojs.
    2.  If path-based routing (e.g., `BrowserRouter`) causes issues (e.g., Neutralinojs trying to fetch non-existent files from the filesystem based on the URL path), switch to hash-based routing (`HashRouter`) in the React application. This is a common adjustment for single-page apps running in file-based environments.

## Phase 2: Modify Build Process (`build_desktop.sh`)

### Task 2.1: Add Step to Build the React Frontend
*   **Objective:** Automate the build of the main React application as part of the overall desktop app build.
*   **Steps:**
    1.  In `build_desktop.sh`, *before* the PyInstaller step for the backend (or in parallel if possible, but sequence is safer), add commands to:
        *   Navigate to the `frontend/` directory (where the React app's `package.json` is).
        *   Run `npm install` (or `yarn install`) to ensure all frontend dependencies are installed.
        *   Run `npm run build` (or `yarn build`) to generate the static production build of the React application. This typically outputs to `frontend/build/` or `frontend/dist/`.

### Task 2.2: Add Step to Copy React Build Output to Neutralinojs Resource Directory
*   **Objective:** Replace the current simple HTML/JS UI in `ii_agent_desktop/app/` with the newly built React application.
*   **Steps:**
    1.  In `build_desktop.sh`, after the React build is successful:
        *   **Carefully** remove all existing files and folders from the `ii_agent_desktop/app/` directory, **EXCEPT** for the `bin/` subdirectory (which contains the bundled Python backend) and the `assets/` directory (if it contains the app icon or other essential non-React assets). Also, `neutralino.js` itself should be managed carefully (see next task).
        *   Copy all contents from the React application's build output directory (e.g., `frontend/build/`) into the `ii_agent_desktop/app/` directory. This will include `index.html`, static assets (JS, CSS bundles), images, etc.

### Task 2.3: Ensure `neutralino.js` is Correctly Loaded by React App
*   **Objective:** The React application's main HTML file (now the entry point for Neutralinojs) must load the `neutralino.js` client library.
*   **Steps:**
    1.  The `neutralino.js` file is typically provided by the Neutralinojs framework when a project is created or updated. When the React build output replaces the content of `ii_agent_desktop/app/`, this original `neutralino.js` (which might have been in `ii_agent_desktop/app/js/neutralino.js`) could be deleted.
    2.  **Strategy:**
        *   Ensure that `neutralino.js` (from a clean Neutralinojs project or the `neu update` command) is available.
        *   The `build_desktop.sh` script should copy this `neutralino.js` file into the root of the `ii_agent_desktop/app/` directory *after* the React build output has been copied there (or ensure React's build output doesn't overwrite a pre-placed one).
        *   Modify the React application's main HTML template (usually `frontend/public/index.html`) to include the script tag: `<script src="./neutralino.js"></script>`. This tag should be placed before any React bundle script tags. The path `./neutralino.js` assumes `neutralino.js` is copied to the root of the `app/` directory.

### Task 2.4: Adjust `neutralino.config.json`
*   **Objective:** Ensure the Neutralinojs configuration correctly points to the React application's entry point and client library.
*   **Steps:**
    1.  Verify `documentRoot` in `neutralino.config.json` is still `/app/`.
    2.  Verify `url` is `/` or `/index.html` (this should now point to the `index.html` file generated by the React build process, which is copied to the root of `app/`).
    3.  The `cli.clientLibrary` path in `neutralino.config.json` should be updated to `/neutralino.js` (assuming `neutralino.js` is now at the root of the `app/` directory).

## Phase 3: Adapt Neutralinojs Shell Script (if any remains)

### Task 3.1: Redefine the Role of `ii_agent_desktop/app/js/main.js`
*   **Objective:** The JavaScript file referenced by `cli.clientLibrary` (e.g., `/neutralino.js` itself, or a minimal bootstrap script like `app_bootstrap.js` that loads `neutralino.js` then React) will be primarily responsible for initializing Neutralino, launching the Python backend, and injecting necessary data into the `window` object for the React app to consume.
*   **Steps:**
    1.  The existing `ii_agent_desktop/app/js/main.js` and `ii_agent_desktop/app/js/communication.js` will be largely superseded by the React application's own logic and the new bootstrap/shell script.
    2.  Create a new minimal "shell" or "bootstrap" JavaScript file (e.g., `ii_agent_desktop/app/app_bootstrap.js`).
    3.  This `app_bootstrap.js` will:
        *   Initialize Neutralinojs (`Neutralino.init()`).
        *   Perform tasks previously handled by `communication.js` for launching the Python backend:
            *   Get the application data path: `const appDataPath = await Neutralino.filesystem.getPath('data'); const backendDataRootPath = \`\${appDataPath}/ii_agent_backend_data\`;`
            *   Spawn the Python process: `Neutralino.extensions.spawnProcess(...)`, passing `backendDataRootPath`.
            *   Listen to Python's stdout for the `PORT:<number>` message.
        *   Once the port and `backendDataRootPath` are known, inject them into the global `window` scope:
            *   `window.NL_EMBEDDED_PYTHON_PORT = capturedPort;`
            *   `window.NL_APP_DATA_PATH = backendDataRootPath;`
            *   `window.NL_DEVICE_ID = await getOrStoreDeviceId();` (if `getOrStoreDeviceId` is moved here).
        *   This script should also handle the `windowClose` event to terminate the Python backend process using `Neutralino.extensions.killProcess()`.
    4.  The React application's `index.html` (now at `ii_agent_desktop/app/index.html`) must load this `app_bootstrap.js` *after* `neutralino.js` and *before* its own main React bundle.
        ```html
        <!-- Example in React's built index.html (now ii_agent_desktop/app/index.html) -->
        <script src="./neutralino.js"></script>
        <script src="./app_bootstrap.js"></script> <!-- Loads bootstrap, which sets window vars -->
        <!-- Then React's own <script defer="defer" src="/static/js/main.xxxx.js"></script> -->
        ```
    5.  The `cli.clientLibrary` in `neutralino.config.json` should point to this new `app_bootstrap.js` (e.g., `/app_bootstrap.js`).
    6.  All UI rendering, event handling (chat messages, user input), and application state management will now be the responsibility of the React application.

## Phase 4: Testing and Refinement

### Task 4.1: End-to-End Testing
*   **Objective:** Ensure the fully integrated application (React UI from `frontend/` + embedded Python backend + Neutralinojs shell + new build process) works correctly.
*   **Steps:**
    1.  Execute the modified `build_desktop.sh` to build the entire application.
    2.  Launch and test the application on target platforms (Windows, macOS, Linux).
    3.  Verify all critical functionalities:
        *   Python backend starts as expected.
        *   React frontend loads correctly and initializes its WebSocket connection to the embedded backend using the dynamically injected port.
        *   Core II-Agent features (sending queries, displaying agent responses, tool interactions) work through the React UI.
        *   File uploads using Neutralinojs dialogs and WebSocket transfer work as implemented in the React app.
        *   `NeutralinoBridgeTool` interactions (notifications, dialogs triggered by the agent) are handled correctly by the React app.
        *   Application data (workspaces, logs) is correctly stored within the path derived from `Neutralino.filesystem.getPath('data')`.
        *   The application exits cleanly, ensuring the Python backend process is terminated.

### Task 4.2: Debugging
*   **Objective:** Identify and resolve any issues arising from the integration.
*   **Steps:**
    1.  Utilize browser developer tools (F12 or via Neutralinojs debug options) for debugging the React frontend and the `app_bootstrap.js` shell script.
    2.  Inspect logs from the Python backend (now located in the application's data directory).
    3.  Check Neutralinojs client logs for any errors related to API calls or process management.

### Task 4.3: Documentation Update
*   **Objective:** Update all relevant project documentation to reflect the new architecture and build process.
*   **Steps:**
    1.  Update the main repository `README.md` to detail the self-contained desktop application architecture using the React frontend and the updated build instructions.
    2.  Update `ii_agent_desktop/README.md` (or consolidate it into the main README) with information specific to running and developing the Neutralinojs application with the integrated React frontend.
    3.  Ensure any developer notes or contribution guidelines are updated.

This integration represents a significant architectural shift for the desktop application, aiming for a richer UI experience by leveraging the existing, more complex React frontend. Each phase and task will require careful planning and execution.
