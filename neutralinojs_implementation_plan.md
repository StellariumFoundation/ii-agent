# Neutralinojs Implementation Plan for II-Agent Desktop Client

This document outlines the plan for developing a cross-platform desktop application for II-Agent using Neutralinojs.

## Part 1: Analysis of Building a Cross-Platform Desktop App with Neutralinojs for II-Agent

### Introduction

The primary goal is to create a new, lightweight, cross-platform desktop client for the existing II-Agent. This client will provide a native-like experience for users interacting with the agent, leveraging web technologies for the user interface via Neutralinojs.

### Leveraging Existing II-Agent Backend

*   **Client-Server Architecture:** The Neutralinojs application will function as a client to the current Python backend server (`ws_server.py`). The core agent logic, tool execution, and LLM interaction will remain in the Python backend.
*   **Communication Protocol:** Communication will primarily occur via WebSockets. The frontend will send user inputs and commands, and the backend will send `RealtimeEvent` JSON objects back to the frontend. This aligns with the existing communication patterns defined in `frontend/typings/agent.ts` (for event structures) and `src/ii_agent/core/event.py` (for server-side event definitions).
*   **Existing API Endpoints:** The desktop client can utilize existing HTTP API endpoints where appropriate, such as `/api/upload` for file uploads (though direct WebSocket communication for this is also an option). Session history and other relevant backend services will be consumed as they are by the current web frontend.

### Neutralinojs Frontend

*   **Structure:** The frontend will be built using standard web technologies: HTML for structure, CSS for styling, and JavaScript for logic and interactivity.
*   **Responsibilities:**
    *   Establishing and maintaining the WebSocket connection to `ws_server.py`.
    *   Sending user inputs (queries, commands) to the backend.
    *   Receiving `RealtimeEvent` objects from the backend and dynamically updating the UI to display agent messages, tool calls, tool results, system notifications, etc.
    *   Managing local UI state (e.g., current input, connection status, display settings).
*   **UI Inspiration:** The existing React frontend (`frontend/components/`) will serve as a strong source of inspiration for UI elements (chat bubbles, tool call displays, error messages) and event handling logic. While not a direct port, reusable patterns can be adapted.

### Workspace and File Management

*   **Interaction with II-Agent Workspace:** The Neutralinojs app will interact with the II-Agent's workspace concept primarily through the backend. The backend manages the workspace (e.g., `/workspace/{session_id}/`).
*   **Accessing Generated Files:** Files generated by tools and saved in the agent's workspace can be accessed in a few ways:
    *   If the backend serves the workspace directory statically, the Neutralinojs app can display images/files using their URLs.
    *   For direct local access (if the agent and Neutralinojs app run on the same machine, which is typical for a desktop app), Neutralinojs could potentially access files directly if paths are known and permissions allow, but it's generally safer to go via the backend. The backend can provide file content or paths as part of `RealtimeEvent`s.
*   **File Uploads:** Users will be able to upload files from their desktop environment to the agent's workspace. This can be achieved using:
    *   Neutralinojs's native file dialogs (`Neutralino.os.showOpenDialog`) to select files.
    *   JavaScript to read the file content (e.g., as base64 or text).
    *   Sending the file data to the backend's `/api/upload` endpoint or via a dedicated WebSocket message.

### Tool Integration

*   **Standard Backend Tools:** Most existing `LLMTool` subclasses, which are non-UI specific (e.g., file I/O, code execution, web search), should function without any modification, as their execution is handled entirely by the Python backend. The Neutralinojs app will simply display their calls and results.
*   **Browser Automation Tools (Playwright):** Existing Playwright-based tools will continue to run on the backend. The Neutralinojs app will not directly participate in the browser automation itself (i.e., it won't *be* the browser being automated). It will display the *results* of these tools, such as summaries of web pages or outcomes of automated actions, as communicated by the backend.
*   **Neutralinojs-Specific Tools (Desktop Bridge):**
    *   **Need:** There's a strong potential for new tools that allow the LLM agent to interact directly with the user's desktop environment through the Neutralinojs application. This could include actions like showing native file save/open dialogs prompted by the agent, displaying native OS notifications, or running local scripts managed by Neutralinojs (with user permission).
    *   **High-Level Design:**
        1.  **Python `LLMTool` Subclass:** Create a new tool in Python (e.g., `DesktopBridgeTool`). This tool would define actions like `show_notification`, `show_file_dialog`, `run_local_command`.
        2.  **Command Dispatch:** When this Python tool's `run_impl` method is called, it would send a specific command to the Neutralinojs frontend. This could be achieved by:
            *   Sending a special `RealtimeEvent` (e.g., type `NEUTRALINO_COMMAND`) through the existing WebSocket connection. The event payload would specify the Neutralinojs function to call and its arguments.
            *   (Less likely, but possible) A simple local HTTP request from the Python backend to a tiny HTTP server that the Neutralinojs app could run, if direct WebSocket communication for this proves cumbersome.
        3.  **JavaScript Handlers:** In the Neutralinojs app, JavaScript handlers would listen for these `NEUTRALINO_COMMAND` events (or HTTP requests).
        4.  **Execution:** Upon receiving a command, the JavaScript handler would execute the corresponding Neutralinojs API function (e.g., `Neutralino.os.showNotification(...)`, `Neutralino.os.showSaveDialog(...)`).
        5.  **Result Feedback:** The result of the Neutralinojs API call (e.g., selected file path, success/failure status) needs to be sent back to the Python `DesktopBridgeTool`. This could be done by:
            *   The Neutralinojs app sending another `RealtimeEvent` (e.g., type `NEUTRALINO_RESULT`) back to the backend via WebSocket.
            *   The Python tool could poll or await this specific event.

### Packaging and Distribution

*   Neutralinojs excels at creating lightweight, cross-platform executables (Windows, macOS, Linux) from web code. The `neu build --release` command will package the HTML, CSS, JavaScript, and the Neutralinojs binary into a distributable application. This simplifies deployment significantly.

### Benefits of Neutralinojs for II-Agent

*   **Cross-Platform:** Single codebase for Windows, macOS, and Linux desktop apps.
*   **Lightweight:** Neutralinojs apps are typically much smaller in size compared to Electron apps.
*   **Web Technologies:** Allows leveraging existing web development skills and potentially parts of the existing web frontend's UI logic/components.
*   **Deeper OS Integration Potential:** Through Neutralinojs APIs and custom tools, the agent can gain capabilities to interact more directly with the user's operating system than a standard web application.

## Part 2: Comprehensive List of Tasks to Build the Desktop Software

This checklist outlines the actionable steps for developing the Neutralinojs desktop client for II-Agent.

### Phase 1: Project Setup & Basic Backend Communication

1.  [ ] **Set up Neutralinojs Project:**
    *   [ ] Install Neutralinojs CLI (`npm install -g @neutralinojs/neu`).
    *   [ ] Create a new project: `neu create ii_agent_desktop --template neutralinojs/neutralinojs-minimal`.
    *   [ ] `cd ii_agent_desktop`.
2.  [ ] **Design Basic HTML Structure:**
    *   [ ] Create `index.html` (or modify the default) with main areas:
        *   Input text area/bar.
        *   Message display area.
        *   Status indicators (e.g., for WebSocket connection).
3.  [ ] **Implement JavaScript WebSocket Module (`js/communication.js`):**
    *   [ ] Function to establish WebSocket connection to `ws_server.py` (configurable URL, e.g., `ws://localhost:8765`).
    *   [ ] On successful connection, send an `init_agent` message (structure from `agent.ts`, potentially including tool settings if configurable from UI later).
    *   [ ] Function to send user `query` messages (JSON, matching `RealtimeEvent` structure for user input).
    *   [ ] Function to receive and log all `RealtimeEvent`s from the server to the browser console.
    *   [ ] Implement basic error handling and reconnection logic for WebSocket (display connection status in UI).
4.  [ ] **Basic UI for Raw Event Display:**
    *   [ ] In `js/main.js` (or similar), on receiving a message, append the raw JSON string to a `<pre>` tag or similar in `index.html` for initial debugging.
5.  [ ] **Backend Readiness:**
    *   [ ] Ensure the II-Agent backend (`ws_server.py`) is running and accessible from the Neutralinojs app.
    *   [ ] Verify Neutralinojs can connect to the WebSocket server.

### Phase 2: Core UI Implementation (Displaying Agent Interaction)

1.  [ ] **Develop UI Rendering for `RealtimeEvent` Types (`js/ui.js`):**
    *   [ ] Function to handle incoming `RealtimeEvent`s.
    *   [ ] Logic to differentiate event types (`type` field) and render them appropriately:
        *   [ ] User messages (echoed back or directly from input).
        *   [ ] Agent text responses (`AGENT_RESPONSE`) - display agent's text.
        *   [ ] Tool calls (`TOOL_CALL`) - display tool name and formatted input arguments.
        *   [ ] Tool results (`TOOL_RESULT`) - display formatted tool output.
        *   [ ] System messages (`SYSTEM`), errors (`ERROR`), processing indicators (`PROCESSING`).
2.  [ ] **Implement Scrollable Chat/Log Area:**
    *   [ ] Use CSS for a scrollable `div` that automatically scrolls to the latest message.
    *   [ ] Style messages (user, agent, tool, system) distinctly (e.g., using different CSS classes, inspired by `frontend/components/`).
3.  [ ] **Create User Input Field:**
    *   [ ] HTML `<textarea>` or `<input type="text">` for user instructions.
4.  [ ] **Implement "Send" Button:**
    *   [ ] HTML `<button>` that, on click, takes text from the input field and sends it via the WebSocket module.
    *   [ ] (Optional) Handle "Enter" key press in the input field to send message.
5.  [ ] **(Optional Initial) UI for File Attachments:**
    *   [ ] Basic input field to specify a file path/name to be included in the message to the agent. Actual upload comes later.

### Phase 3: Advanced Features & Tooling

1.  [ ] **Implement File Upload Functionality:**
    *   [ ] Add a button or mechanism to trigger file selection.
    *   [ ] Use `Neutralino.os.showOpenDialog({})` to allow users to select files from their desktop.
    *   [ ] JavaScript to read file content:
        *   `Neutralino.filesystem.readFile` for text files.
        *   `Neutralino.filesystem.readBinaryFile` for binary files (returns ArrayBuffer, convert to Base64 string if sending as JSON).
    *   [ ] Send file content to the backend:
        *   Option A: Use `fetch` or `XMLHttpRequest` to POST to the existing `/api/upload` endpoint.
        *   Option B: Define a new `RealtimeEvent` type for file uploads (e.g., `FILE_UPLOAD`) and send data (e.g., filename, content as base64) via WebSocket. Backend needs handler for this. (Consider `/api/upload` first).
    *   [ ] Update UI to indicate file selection and upload progress/completion.
2.  [ ] **Develop `NeutralinoBridgeTool` (Desktop Interaction via LLM):**
    *   **Python Side (New `LLMTool` in `src/ii_agent/tools/`):**
        *   [ ] Define `NeutralinoBridgeTool(LLMTool)` class.
        *   [ ] Attributes: `name = "desktop_interaction"`, `description = "Interacts with the user's desktop via the Neutralinojs app (e.g., show notifications, file dialogs)."`.
        *   [ ] `input_schema`: Pydantic model defining commands (e.g., `action: Literal["show_notification", "show_save_dialog"]`, `title: Optional[str]`, `content: Optional[str]`, `default_path: Optional[str]`).
        *   [ ] `run_impl(**kwargs)`:
            *   Construct a payload for the Neutralinojs command.
            *   Send a custom `RealtimeEvent` (e.g., `{"type": "NEUTRALINO_COMMAND", "data": {"command_id": "unique_id", "action": "show_notification", "payload": {...}}}`) to the frontend via the agent's existing message queue.
            *   Implement logic to wait for a corresponding `NEUTRALINO_RESULT` event from the frontend (e.g., by subscribing to an event queue or using a future/promise mechanism if Python's async capabilities are leveraged).
    *   **JavaScript Side (Neutralinojs App in `js/main.js` or `js/neutralino_bridge.js`):**
        *   [ ] Add listener for `RealtimeEvent`s of type `NEUTRALINO_COMMAND`.
        *   [ ] Based on `event.data.action`:
            *   If `show_notification`: `Neutralino.os.showNotification(event.data.payload.title, event.data.payload.content)`.
            *   If `show_save_dialog`: `Neutralino.os.showSaveDialog(event.data.payload.title, { defaultPath: event.data.payload.defaultPath })`.
            *   (Add other Neutralinojs functions as needed).
        *   [ ] After execution, send the result back to the Python backend.
            *   Construct a new `RealtimeEvent` (e.g., `{"type": "NEUTRALINO_RESULT", "data": {"command_id": "unique_id_from_request", "status": "success/error", "result": ...}}`).
            *   Send this event via the WebSocket connection.
    *   **Backend `ws_server.py` Modifications:**
        *   [ ] Add handler to receive `NEUTRALINO_RESULT` events from the client.
        *   [ ] Use `command_id` to route the result back to the waiting `NeutralinoBridgeTool` instance.
    *   **Tool Registration:**
        *   [ ] Register `NeutralinoBridgeTool` with the `AgentToolManager` in the backend.
3.  [ ] **Implement UI for Managing Tool Settings (Optional based on need):**
    *   [ ] If tools require runtime settings (similar to `frontend/typings/agent.ts` `ToolSettings`), create a UI panel to configure these.
    *   [ ] Send these settings with the `init_agent` message or via a dedicated settings message.
4.  [ ] **Display Media from Workspace:**
    *   [ ] If a tool result contains a path to an image or other media within the agent's workspace (and that workspace is served statically by the backend), update the UI to display it (e.g., using an `<img>` tag with the correct URL).

### Phase 4: Packaging & Polish

1.  [ ] **Thorough Testing:**
    *   [ ] Test core functionality on Windows.
    *   [ ] Test core functionality on macOS.
    *   [ ] Test core functionality on Linux.
2.  [ ] **UI/UX Refinements:**
    *   [ ] Improve CSS styling for a polished look and feel.
    *   [ ] Enhance error display and handling in the UI.
    *   [ ] Add clear loading states or visual feedback during backend processing or tool execution.
3.  [ ] **Application Icons:**
    *   [ ] Create or source appropriate icons for the application (e.g., `.ico` for Windows, `.icns` for macOS).
4.  [ ] **Configure `neutralino.config.json`:**
    *   [ ] Set `applicationId`, `appName`, `version`.
    *   [ ] Configure `modes.window` (title, width, height, icon, etc.).
    *   [ ] Define necessary `nativeAllowList` entries for Neutralinojs API usage (e.g., `os.*`, `filesystem.*`).
    *   [ ] Add `cli.binaryName`.
5.  [ ] **Build Distributables:**
    *   [ ] Run `neu build --release` to generate executables for all target platforms.
    *   [ ] Test the packaged applications.
6.  [ ] **Basic User Documentation:**
    *   [ ] Write a simple `README.md` or guide covering:
        *   How to download and install/run the desktop application on different platforms.
        *   Basic usage instructions.
        *   How to configure the backend URL if necessary.

This plan provides a roadmap for development. Tasks within phases can be parallelized where appropriate, and priorities may be adjusted based on development progress and feedback.Okay, the `neutralinojs_implementation_plan.md` file has been created with the detailed analysis and task list.
